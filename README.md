***
# JDBC 등장
DB 마다 커넥션 방법, SQL전달 방법, 결과를 받는 방법이 다르다.

때문에 DB를 변경하게 되면 애플리케이션의 코드도 같이 변경해야한다.

이 문제를 해결하기 위해 JDBC라는 자바 표준이 등장했다.
***
# JDBC 표준인터페이스
대표적으로 다음 3가 기능을 표준 인터페이로 정해서 제공한다.
> 연결 - java.sql.Connection
>
> 질의 - java.sql.Statement
>
> 응답 - java.sql.ResultSet

각각의 DB벤더에서 자신의 DB에 맞게 JDBC 인터페이스를 구현한 라이브러리 제공한다.

이를 ```JDBC Driver```라고 한다.
***
# JDBC DB Connection
JDBC가 제공하는 ```DriverManager```는 라이브러리에 등록된 DB Driver들을 관리하고, 커넥션을 획득하는 기능을 제공한다.

JDBC는 아래와 같은 방법으로 DB와 연결한다.

1. 애플리케이션에서 DB Connection이 필요하면 ```DriverManager.getConnection()```을 호출한다.
2. ```DriverManager```는 라이브러리에 등록된 ```JDBC Driver``` 목록을 자동으로 인식하고 이 드라이버들에게 url, 이름, 비밀번호 정보를 넘겨
커넥션을 획득 할 수 있는지 확인한다.
3. 커넥션을 처리할 수 있는 드라이버의 커넥션 구현체를 반환한다.

***
# 표준화의 한계
JDBC의 등장으로 많은 것이 편리해졌다.

하지만 DB마다 SQL, 데이터 타입 등이 달라 일부분만 공통화 했기 때문에 한계가 있다.

결국 DB를 변경하면 JDBC 코드는 변경하지 않아도 되지만 SQL은 해당 DB에 맞게 변경해야 한다.

JPA(Java Persistence API)를 사용하면 이렇게 각각의 DB 마다 다른 SQL정의의 문제도 많은 부분 해결할 수 있다.
***
# JDBC와 최신 DB 접근 기술
JDBC는 1977년에 출시된 오래된 기술이고 사용방법도 복잡하다.
그래서 최근에는 JDBC를 직접 사용하기 보다는 JDBC를 편리하게 사용할 수 있게 해주는 기술들을 사용한다.
대표적으로 SQL Mapper와 ORM 기술이 있다.

* SQL Mapper
  * 장점
    * SQL 응답결과를 객체로 편리하게 변환해준다.
    * JDBC의 반복코드를 제거해준다.
  * 단점
    * 개발자가 SQL을 직접 작성해야한다.
  * 대표기술
    * Spring JdbcTemplate, Mybatis
  
* ORM
    * 장점
      * 객체를 관계형 데이터베이스 테이블과 매핑해준다.
      * ORM기술이 개발자 대신 SQL을 동적으로 실행해준다.
      * 각각의 데이터베이스마다 다른 SQL을 사용하는 문제도 중간에서 해결해준다.
    * 단점
      * ORM이 동적으로 생성한 SQL은 때로는 개발자가 직접 작성한 SQL보다 느리거나 효율이 떨어질 수 있다.
    * 대표기술
      * JPA, 하이버네이트, 이클립스링크
***
# Connection Pool
데이터베이스 커넥션을 획들 할 때에는 많은 자원과 복잡한 과정을 거치게 된다. 사용자가 애플리케이션을 사용할 때 SQL을 실행하는 시간 뿐만 아니라 커넥션을 새로 만드는 시간까지 추가가 되어 응답속도에 영향을 준다.

이런 문제를 해결하는 아이디어가 ```Connection Pool```이라는 방법이다.
* 커넥션 풀 초기화
  * 애플리케이션을 시작하는 시점에 필요한 만큼 커넥션을 생성해 풀에 보관한다.
  * 커넥션 풀에 들어있는 커넥션들은 이미 데이터베이스와 연결이 되어있는 상태이기 때문에 즉시 데이터베이스에 SQL을 전달 할 수 있다.
* 커넥션 풀 사용
  * 애플리케이션은 이제 데이터베이스 드라이버를 통해 새로운 커넥션을 획득하는 것이 아니라 풀에 생성되어있는 커넥션을 가져다 쓰면된다.
  * 커넥션 풀은 커넥션을 요청하면 자신이 가지고 있는 커넥션 중 하나를 반환해준다.
  * 애플리케이션은 커넥션을 사용하고 종료시키는 것이 아니라 다음번에 다시 사용할 수 있도록 커넥션풀에게 커넥션을 반환한다.
* 대표적인 커넥션 풀 오픈소스
  * commons-dbcp2
  * tomcat-jdbc pool
  * Hikari CP
***
# DataSource
애플리케이션이 커넥션을 획득하는 방법은 ```DriverManager```를 사용하거나 ```ConnectionPool```을 사용하는 등 다양한 방법이 있다.


각 방법은 커넥션 획득방법, 사용법 등이 다르다. 이 때문에 커넥션 획득 방법을 변경하게 되면 마치 JDBC를 사용하지 않을때 데이터베이스를 변경하는 경우처럼 애플리케이션 코드에 변경이 필요한 문제가 발생한다.


이 문제를 해결하기 위해 커넥션 획득방법을 추상화한 ```DataSource```인터페이스가 등장하게 된다.
애플리케이션을 ```DataSource```인터페이스에 의존하도록 하면 커넥션 획득 방법을 변경해도 애플리케이션 코드는 변경하지 않아도 된다.
설정과 사용을 분리할 수 있다.
***
# Transaction
데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻한다. 트랜잭션을 안전하게 처리하기 위해서는 고려해야 할 점들이 많다.

> Transaction ACID
> 
>   >원자성(Atomicity)
>   >
>   >트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.
>   
>   >일관성(Consistency)
>   >
>   >모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
> 
>   >격리성(Isolation)
>   >
>   >동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
>
>   >지속성(Durability)
>   >
>   >트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

* 트랜잭션 격리 수준 - Isolation level
  * READ UNCOMMITED(커밋되지 않은 읽기)
  * READ COMMITTED(커밋된 읽기)
  * REPEATABLE READ(반복 가능한 읽기)
  * SERIALIZABLE(직렬화 가능) 
***
# Transaction Commit, Rollback
* 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영 할려면 ```commit```을 호출한다.
* 데이터 변경을 반영하고 싶지 않으면 ```rollback```을 호출한다.
* ```commit```을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만
데이터가 보이고 다른세션(사용자)에게는 변경된 데이터가 보이지 않는다.
***
# Transaction 문제
트랜잭션 템플릿 덕분에, 트랙잭션을 사용할 때 반복하는 코드를 제거 할 수 있었다.
하지만 이곳은 서비스 로적인데 비즈니스 로직 뿐만 아니라 트랙잭션을 처리하는 기술 로직이 함께 포함되어있다.
이렇게 비즈니스 로직과 트랜잭션을 처리하는 기술 로직이 한 곳에 있으면 두 관심사를 하나의 클래스에서
처리하게 된다. 결과적으로 코드를 유지보수하기 어려워진다.
***
# Spring과 문제 해결 - Transaction
* 프레젠테이션 계층
  * UI와 관련된 처리 담당
  * 웹 요청과 응답
  * 사용자 요청을 검증
  * 주 사용기술: 서블릿과 HTTP 같은 웹기술, 스프링MVC
* 서비스 계층
  * 비즈니스 로직 담당
  * 가급적 특정 기술에 의존하지 않고 순수 자바코드로 작성
* 데이터 접근 계층
  * 실제 데이터베이스에 접근하는 코드
  * 주 사용기술: JDBC, JPA, File, Redis, Mongo ...

> 순수한 서비스 계층
> 
> 시간이 흘러 UI와 데이터 저장 기술은 변경해도 비즈니스 로직은 최대한 변경 없이 유지되어야 한다.
> 이렇게 하려면 서비스 계층을 특정 기술에 종속적이지 않게 개발해야 한다.
> 향후 구현 기술이 변경될 때 변경의 영향 범위를 최소화 할 수 있다.

스프링은 서비스 계층을 순수하게 유지하면서, 문제를 해결할 수 있는 다양한 방법과 기술을 제공한다.

### 스프링의 트랜잭션 추상화
스프링 트랜잭션 추상화의 핵심은 ```PlatformTransactionManager``` 인터페이스이다.
```org.springframework.transaction.PlatformTransactionManager```

### 스프링의 트랜잭션 동기화
스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 한다.
* 트랜잭션 추상화
* 리소스 동기화

동작 방식을 간단하게 설명하면 다음과 같다.
1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭
   션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전
   달하지 않아도 된다.
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료
   하고, 커넥션도 닫는다

### 스프링의 트랜잭션 템플릿
트랜잭션을 시작하고, 비즈니스 로직을 실행하고, 성공하면 커밋하고, 예외가 발생해서 실패하면 롤백한다.
이런 형태는 각각의 서비스에서 반복된다. 달라지는 부분은 비즈니스 로직 뿐이다.
이럴 때 템플릿 콜백 패턴을 활용하면 이런 반복 문제를 깔끔하게 해결할 수 있다.

템플릿 콜백 패턴을 적용하려면 템플릿을 제공하는 클래스를 작성해야 하는데, 스프링은
```TransactionTemplate``` 라는 템플릿 클래스를 제공한다

***
# Transaction AOP 이해
트랜잭션을 편리하게 처리하기 위해서 트랜잭션 추상화도 도입하고, 추가로 반복적인 트랜잭션 로
직을 해결하기 위해 트랜잭션 템플릿도 도입했다.
트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있었다. 하지만 서비스 계층에 순수한
비즈니스 로직만 남긴다는 목표는 아직 달성하지 못했다.
이럴 때 스프링 AOP를 통해 프록시를 도입하면 문제를 깔끔하게 해결할 수 있다.

### 스프링의 트랜잭션 프록시
* 프록시 도입 전: 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다.
* 프록시 도입 후: 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에
실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다.

### 스프링이 제공하는 트랜잭션 AOP
* 스프링이 제공하는 AOP 기능을 사용하면 프록시를 매우 편리하게 적용할 수 있다. 스프링 핵심 원리 - 고급
편을 통해 AOP를 열심히 공부하신 분이라면 아마도 ```@Aspect``` , ```@Advice``` , ```@Pointcut``` 를 사용해서 트랜
잭션 처리용 AOP를 어떻게 만들지 머리속으로 그림이 그려질 것이다.
* 물론 스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만, 트랜잭션은 매우 중요한 기능이고, 전세계
누구나 다 사용하는 기능이다. 스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다. 스프링 부
트를 사용하면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록해준다.
* 개발자는 트랜잭션 처리가 필요한 곳에 ```@Transactional``` 애노테이션만 붙여주면 된다. 스프링의 트랜잭
션 AOP는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다


### @Transaction
```org.springframework.transaction.annotation.Transactional```
> 참고
> 
> 스프링 AOP를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요하다. 스프링은 트랜잭션 AOP 처리를
위해 다음 클래스를 제공한다. 스프링 부트를 사용하면 해당 빈들은 스프링 컨테이너에 자동으로 등록된다.
> 
> 어드바이저: ```BeanFactoryTransactionAttributeSourceAdvisor```
> 
> 포인트컷: ```TransactionAttributeSourcePointcut```
> 
> 어드바이스: ```TransactionInterceptor```